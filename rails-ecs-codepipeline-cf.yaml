Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Basic Settings
        Parameters:
          - AppName
          - RailsMasterKey
      - Label:
          default: Database Settings
        Parameters:
          - DatabaseUsername
          - DatabaseSnapshotIdentifier
          - UseLatestDatabaseSnapshot
      - Label:
          default: Storage Settings
        Parameters:
          - CodePipelineArtifactsBucketName
          - ECRRepositoryName
          - AccessLogsBucketExists
      - Label:
          default: Deployment Settings
        Parameters:
          - ECRImageExists
          - GitHubRepo
          - GitHubBranch
          - CodeStarConnectionArn
      - Label:
          default: Domain Settings
        Parameters:
          - DomainName
          - SubdomainName
Parameters:
  # Basic Settings
  AppName:
    Type: String
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9]*$
    Description: 'Application name that will be used as a prefix for all AWS resources (VPC, RDS, ECS, etc.). Must start with a letter and contain only letters and numbers. Example: MyApp, ProductionApp'
    Default: CodePipelineTutorial
  RailsMasterKey:
    Type: String
    Description: 'Rails master key for encrypting credentials and session data. Find this in your Rails app at config/master.key or generate with "rails credentials:edit". IMPORTANT: Keep this secret secure and never commit it to version control.'
    NoEcho: true
  # Database Settings
  DatabaseUsername:
    Type: String
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9_]{0,15}$
    Default: admin
    Description: 'Database administrator username for Aurora MySQL. Must be 1-16 characters, start with a letter, and contain only letters, numbers, and underscores. The password will be automatically generated and stored in AWS Secrets Manager.'
  DatabaseSnapshotIdentifier:
    Type: String
    Default: ''
    Description: 'Optional: Specific RDS snapshot ARN or identifier to restore from (e.g., rds:my-cluster-2024-01-01-12-00). Leave empty to create a new database cluster. If UseLatestDatabaseSnapshot is "yes", this parameter is ignored.'
  UseLatestDatabaseSnapshot:
    Type: String
    Default: 'no'
    AllowedValues:
      - 'yes'
      - 'no'
    Description: "Set to 'yes' to automatically find and use the latest available manual snapshot from the database cluster. If 'yes', the DatabaseSnapshotIdentifier parameter is ignored and AppName parameter must match the stack that produced the snapshot. Useful for automated restores without specifying exact snapshot IDs."
  # Storage Settings
  CodePipelineArtifactsBucketName:
    Type: String
    AllowedPattern: ^[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$
    Default: codepipeline-artifacts
    Description: 'Base name for the S3 bucket that stores CodePipeline build artifacts. The actual bucket name will be "{base-name}-{account-id}-{region}". Must be globally unique across all AWS accounts. Use lowercase letters, numbers, dots, and hyphens only.'
  ECRRepositoryName:
    Type: String
    AllowedPattern: ^[a-z0-9]+(?:[._-][a-z0-9]+)*$
    Default: code-pipeline-tutorial-repo
    Description: 'Name of the Amazon ECR repository where Docker images will be stored. Use lowercase letters, numbers, dots, underscores, and hyphens only. Example: my-app-repo, production-images'
  AccessLogsBucketExists:
    Type: String
    Default: 'no'
    AllowedValues:
      - 'yes'
      - 'no'
    Description: "Set to 'yes' to reuse the ALB access-log bucket created by a previous deployment (the bucket name is derived from the stack name, so deploy with the same stack name). Ensure the bucket already exists in this account/region and still allows ALB log delivery. Set to 'no' to let this stack create and manage a new bucket automatically."
  # Deployment Settings
  ECRImageExists:
    Type: String
    AllowedValues:
      - 'yes'
      - 'no'
    Default: 'no'
    Description: "Set to 'no' for the first deployment (when no Docker image exists yet). After CodePipeline successfully builds and pushes your first image to ECR, update this to 'yes' to enable the ECS service. This prevents deployment failures when the image doesn't exist yet."
  GitHubRepo:
    Type: String
    Default: DoiTaiki/code_pipeline_tutorial
    Description: 'GitHub repository in the format "owner/repository-name". This is the repository that CodePipeline will monitor for code changes. Example: myusername/my-rails-app, company/production-app'
  GitHubBranch:
    Type: String
    Default: main
    Description: 'Git branch name that CodePipeline will monitor. When code is pushed to this branch, it will automatically trigger a build and deployment. Common values: main, master, production, staging'
  CodeStarConnectionArn:
    Type: String
    Description: 'ARN of the CodeStar Connections connection to your GitHub account. Create this in AWS Console: Developer Tools > Settings > Connections. Format: arn:aws:codestar-connections:region:account-id:connection/connection-id. This connection allows CodePipeline to access your GitHub repository securely.'
  # Domain Settings
  DomainName:
    Type: String
    Default: rails-template.click
    Description: 'Root domain name for your application (e.g., example.com, myapp.org). This domain must be registered in Route 53 or have its DNS nameservers delegated to Route 53. The template will create a hosted zone and SSL certificate for this domain.'
  SubdomainName:
    Type: String
    Default: www.rails-template.click
    Description: 'Full subdomain name for your application (e.g., www.example.com, app.example.com). For wildcard SSL certificates, use *.example.com format. Note: Wildcard covers only one level (*.example.com covers app.example.com but NOT api.app.example.com).'
Conditions:
  UseECRImage: !Equals
    - !Ref 'ECRImageExists'
    - 'yes'
  IsWildcardSubDomain: !Equals
    - !Select
      - 0
      - !Split
        - .
        - !Ref 'SubdomainName'
    - '*'
  CreateNewCluster: !Equals
    - !Ref 'DatabaseSnapshotIdentifier'
    - ''
  UseAutomaticLookup: !Equals
    - !Ref 'UseLatestDatabaseSnapshot'
    - 'yes'
  CreateNewBucket: !Equals
    - !Ref 'AccessLogsBucketExists'
    - 'no'
  UseExistingAccessLogsBucket: !Equals
    - !Ref 'AccessLogsBucketExists'
    - 'yes'
Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub '${AppName}-vpc'
  PublicSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      MapPublicIpOnLaunch: false
      VpcId: !Ref 'VPC'
      AvailabilityZone: !Select
        - 0
        - !GetAZs ''
      CidrBlock: 10.0.0.0/20
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Join
            - '-'
            - - !Sub '${AppName}-subnet-public1'
              - !Select
                - 0
                - !GetAZs ''
  PublicSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      MapPublicIpOnLaunch: false
      VpcId: !Ref 'VPC'
      AvailabilityZone: !Select
        - 1
        - !GetAZs ''
      CidrBlock: 10.0.16.0/20
      Tags:
        - Key: Name
          Value: !Join
            - '-'
            - - !Sub '${AppName}-subnet-public2'
              - !Select
                - 1
                - !GetAZs ''
        - Key: Application
          Value: !Ref 'AppName'
  PrivateSubnetAz1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      AvailabilityZone: !Select
        - 0
        - !GetAZs ''
      CidrBlock: 10.0.128.0/20
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Join
            - '-'
            - - !Sub '${AppName}-subnet-private1'
              - !Select
                - 0
                - !GetAZs ''
  PrivateSubnetAz2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref 'VPC'
      AvailabilityZone: !Select
        - 1
        - !GetAZs ''
      CidrBlock: 10.0.144.0/20
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Join
            - '-'
            - - !Sub '${AppName}-subnet-private2'
              - !Select
                - 1
                - !GetAZs ''
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${AppName}-igw'
        - Key: Application
          Value: !Ref 'AppName'
  GatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref 'VPC'
      InternetGatewayId: !Ref 'InternetGateway'
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
        - Key: Name
          Value: !Sub '${AppName}-rtb-public'
        - Key: Application
          Value: !Ref 'AppName'
  PrivateRouteTableAz1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Join
            - '-'
            - - !Sub '${AppName}-rtb-private1'
              - !Select
                - 0
                - !GetAZs ''
  PrivateRouteTableAz2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
      Tags:
        - Key: Name
          Value: !Join
            - '-'
            - - !Sub '${AppName}-rtb-private2'
              - !Select
                - 1
                - !GetAZs ''
        - Key: Application
          Value: !Ref 'AppName'
  PublicSubnetRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref 'InternetGateway'
  PublicSubnetAz1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      SubnetId: !Ref 'PublicSubnetAz1'
  PublicSubnetAz2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      SubnetId: !Ref 'PublicSubnetAz2'
  PrivateSubnetAz1Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref 'PrivateRouteTableAz1'
      SubnetId: !Ref 'PrivateSubnetAz1'
  PrivateSubnetAz2Association:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref 'PrivateRouteTableAz2'
      SubnetId: !Ref 'PrivateSubnetAz2'
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub '${AppName}-alb'
      GroupName: !Sub '${AppName}-alb'
      VpcId: !Ref 'VPC'
      SecurityGroupIngress:
        - CidrIp: '0.0.0.0/0'
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        - CidrIp: '0.0.0.0/0'
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          IpProtocol: -1
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  ECSTaskSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub '${AppName}-ecs'
      GroupName: !Sub '${AppName}-ecs'
      VpcId: !Ref 'VPC'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !If [UseECRImage, 3000, 80]
          SourceSecurityGroupId: !Ref 'LoadBalancerSecurityGroup'
          ToPort: !If [UseECRImage, 3000, 80]
          SourceSecurityGroupOwnerId: !Ref 'AWS::AccountId'
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          IpProtocol: -1
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  DatabaseSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub '${AppName}-db'
      GroupName: !Sub '${AppName}-db'
      VpcId: !Ref 'VPC'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3306
          SourceSecurityGroupId: !Ref 'ECSTaskSecurityGroup'
          ToPort: 3306
          SourceSecurityGroupOwnerId: !Ref 'AWS::AccountId'
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          IpProtocol: -1
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  VPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Sub '${AppName}-vpc-endopoint'
      GroupName: !Sub '${AppName}-vpc-endopoint'
      VpcId: !Ref 'VPC'
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          SourceSecurityGroupId: !Ref 'ECSTaskSecurityGroup'
          ToPort: 443
          SourceSecurityGroupOwnerId: !Ref 'AWS::AccountId'
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          IpProtocol: -1
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  LogsVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref 'VPCEndpointSecurityGroup'
      SubnetIds:
        - !Ref 'PrivateSubnetAz1'
        - !Ref 'PrivateSubnetAz2'
      VpcId: !Ref 'VPC'
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.logs'
      VpcEndpointType: Interface
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub 'logs-${AppName}-endopoint-01'
  ECRDkrVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref 'VPCEndpointSecurityGroup'
      SubnetIds:
        - !Ref 'PrivateSubnetAz1'
        - !Ref 'PrivateSubnetAz2'
      VpcId: !Ref 'VPC'
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.dkr'
      VpcEndpointType: Interface
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub 'ecr-dkr-${AppName}-endpoint-01'
  SecretsManagerVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref 'VPCEndpointSecurityGroup'
      SubnetIds:
        - !Ref 'PrivateSubnetAz1'
        - !Ref 'PrivateSubnetAz2'
      VpcId: !Ref 'VPC'
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.secretsmanager'
      VpcEndpointType: Interface
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub 'secretmanager-${AppName}-endpoint-01'
  SSMMessagesVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref 'VPCEndpointSecurityGroup'
      SubnetIds:
        - !Ref 'PrivateSubnetAz1'
        - !Ref 'PrivateSubnetAz2'
      VpcId: !Ref 'VPC'
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ssmmessages'
      VpcEndpointType: Interface
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub 'ssmmessages-${AppName}-endpoint-01'
  ECRAPIVPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !Ref 'VPCEndpointSecurityGroup'
      SubnetIds:
        - !Ref 'PrivateSubnetAz1'
        - !Ref 'PrivateSubnetAz2'
      VpcId: !Ref 'VPC'
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.ecr.api'
      VpcEndpointType: Interface
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub 'ecr-api-${AppName}-endpoint-01'
  S3VPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      VpcId: !Ref 'VPC'
      RouteTableIds:
        - !Ref 'PrivateRouteTableAz1'
        - !Ref 'PrivateRouteTableAz2'
      ServiceName: !Sub 'com.amazonaws.${AWS::Region}.s3'
      VpcEndpointType: Gateway
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub '${AppName}-vpce-s3'
  DatabaseSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Created from the RDS Management Console
      SubnetIds:
        - !Ref 'PrivateSubnetAz1'
        - !Ref 'PrivateSubnetAz2'
      DBSubnetGroupName: !Sub '${AppName}-db-subnet-group'
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub '${AppName}-db-subnet-group'
  RDSMonitoringRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole
      RoleName: !Sub '${AppName}-rds-monitoring-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: monitoring.rds.amazonaws.com
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  SnapshotLookupRole:
    Type: AWS::IAM::Role
    Condition: UseAutomaticLookup
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: RDSSnapshotAccess
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - rds:DescribeDBClusterSnapshots
                  - rds:DescribeDBSnapshots
                Resource: '*'
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  SnapshotLookupFunction:
    Type: AWS::Lambda::Function
    Condition: UseAutomaticLookup
    Properties:
      FunctionName: !Sub '${AWS::StackName}-snapshot-lookup'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt 'SnapshotLookupRole.Arn'
      Timeout: 60
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          from datetime import datetime

          def lambda_handler(event, context):
              try:
                  rds = boto3.client('rds')
                  
                  # Get parameters from CloudFormation
                  source_cluster = event['ResourceProperties']['SourceClusterIdentifier']
                  
                  response_data = {}
                  
                  if event['RequestType'] == 'Delete':
                      # Nothing to do on delete
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                      return
                  
                  # List snapshots for the source cluster
                  snapshots_response = rds.describe_db_cluster_snapshots(
                      DBClusterIdentifier=source_cluster,
                      SnapshotType='manual'
                  )
                  
                  snapshots = snapshots_response['DBClusterSnapshots']
                  
                  if not snapshots:
                      raise Exception(f"No manual snapshots found for cluster {source_cluster}")
                  
                  # Filter only available snapshots
                  available_snapshots = [s for s in snapshots if s['Status'] == 'available']
                  
                  if not available_snapshots:
                      raise Exception(f"No available manual snapshots found for cluster {source_cluster}")
                  
                  # Sort by creation time and get the latest
                  latest_snapshot = sorted(available_snapshots, 
                                         key=lambda x: x['SnapshotCreateTime'], 
                                         reverse=True)[0]
                  
                  # Return the snapshot identifier
                  response_data['LatestSnapshotId'] = latest_snapshot['DBClusterSnapshotIdentifier']
                  response_data['SnapshotCreateTime'] = latest_snapshot['SnapshotCreateTime'].isoformat()
                  response_data['SnapshotStatus'] = latest_snapshot['Status']
                  
                  print(f"Found latest snapshot: {response_data['LatestSnapshotId']}")
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))
  LatestSnapshotLookup:
    Type: AWS::CloudFormation::CustomResource
    Condition: UseAutomaticLookup
    Properties:
      ServiceToken: !GetAtt 'SnapshotLookupFunction.Arn'
      SourceClusterIdentifier: !Sub '${AppName}-db-cluster'
  DatabaseCluster:
    Type: AWS::RDS::DBCluster
    Properties:
      DBClusterIdentifier: !Sub '${AppName}-db-cluster'
      SnapshotIdentifier: !If
        - UseAutomaticLookup
        - !GetAtt 'LatestSnapshotLookup.LatestSnapshotId'
        - !If
          - CreateNewCluster
          - !Ref 'AWS::NoValue'
          - !Ref 'DatabaseSnapshotIdentifier'
      DatabaseName: !If
        - CreateNewCluster
        - !Sub '${AppName}_db'
        - !Ref 'AWS::NoValue'
      ManageMasterUserPassword: !If
        - CreateNewCluster
        - true
        - !Ref 'AWS::NoValue'
      MasterUsername: !If
        - CreateNewCluster
        - !Ref 'DatabaseUsername'
        - !Ref 'AWS::NoValue'
      Engine: aurora-mysql
      EngineVersion: 8.0.mysql_aurora.3.08.2
      EngineLifecycleSupport: open-source-rds-extended-support-disabled
      AvailabilityZones:
        - !Select
          - 0
          - !GetAZs ''
        - !Select
          - 1
          - !GetAZs ''
      DatabaseInsightsMode: standard
      BackupRetentionPeriod: 1
      PreferredBackupWindow: 19:00-19:30
      PreferredMaintenanceWindow: Sun:19:30-Sun:20:00
      CopyTagsToSnapshot: true
      DeletionProtection: false
      StorageEncrypted: true
      EnableHttpEndpoint: false
      MonitoringRoleArn: !GetAtt 'RDSMonitoringRole.Arn'
      MonitoringInterval: 60
      VpcSecurityGroupIds:
        - !Ref 'DatabaseSecurityGroup'
      ServerlessV2ScalingConfiguration:
        MinCapacity: 0
        SecondsUntilAutoPause: 300
        MaxCapacity: 16
      PerformanceInsightsEnabled: true
      PerformanceInsightsRetentionPeriod: 7
      DBSubnetGroupName: !Ref 'DatabaseSubnetGroup'
      EnableCloudwatchLogsExports:
        - audit
        - error
        - general
        - slowquery
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  DatabaseInstanceAz1:
    Type: AWS::RDS::DBInstance
    Properties:
      DBClusterIdentifier: !Ref 'DatabaseCluster'
      DBInstanceIdentifier: !Sub '${AppName}-instance-1'
      PubliclyAccessible: false
      Engine: aurora-mysql
      DBInstanceClass: db.serverless
      AvailabilityZone: !Select
        - 0
        - !GetAZs ''
      MonitoringRoleArn: !GetAtt 'RDSMonitoringRole.Arn'
      MonitoringInterval: 60
      DBParameterGroupName: default.aurora-mysql8.0
      CopyTagsToSnapshot: false
      OptionGroupName: default:aurora-mysql-8-0
      PreferredMaintenanceWindow: tue:18:14-tue:18:44
      CACertificateIdentifier: rds-ca-rsa2048-g1
      ManageMasterUserPassword: false
      MasterUserSecret: {}
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  DatabaseInstanceAz2:
    Type: AWS::RDS::DBInstance
    Properties:
      DBClusterIdentifier: !Ref 'DatabaseCluster'
      DBInstanceIdentifier: !Sub '${AppName}-instance-2'
      PubliclyAccessible: false
      Engine: aurora-mysql
      DBInstanceClass: db.serverless
      AvailabilityZone: !Select
        - 1
        - !GetAZs ''
      MonitoringRoleArn: !GetAtt 'RDSMonitoringRole.Arn'
      MonitoringInterval: 60
      DBParameterGroupName: default.aurora-mysql8.0
      CopyTagsToSnapshot: false
      OptionGroupName: default:aurora-mysql-8-0
      PreferredMaintenanceWindow: mon:19:31-mon:20:01
      CACertificateIdentifier: rds-ca-rsa2048-g1
      ManageMasterUserPassword: false
      MasterUserSecret: {}
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  AccessLogsBucket:
    Type: AWS::S3::Bucket
    Condition: CreateNewBucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      BucketName: !Sub '${AWS::StackName}-alb-access-logs-${AWS::AccountId}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerEnforced
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub '${AWS::StackName}-alb-access-logs'
      LifecycleConfiguration:
        Rules:
          - Id: ALBLogsLifecycle
            Status: Enabled
            Transitions:
              - TransitionInDays: 30
                StorageClass: STANDARD_IA
              - TransitionInDays: 90
                StorageClass: GLACIER
              - TransitionInDays: 365
                StorageClass: DEEP_ARCHIVE
            ExpirationInDays: 2555
  AccessLogsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Condition: CreateNewBucket
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      Bucket: !Ref 'AccessLogsBucket'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AWSLogDeliveryAclCheck
            Effect: Allow
            Principal:
              Service: logdelivery.elasticloadbalancing.amazonaws.com
            Action: s3:GetBucketAcl
            Resource: !GetAtt 'AccessLogsBucket.Arn'
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref 'AWS::AccountId'
          - Sid: AWSLogDeliveryWrite
            Effect: Allow
            Principal:
              Service: logdelivery.elasticloadbalancing.amazonaws.com
            Action: s3:PutObject
            Resource: !Sub '${AccessLogsBucket.Arn}/AWSLogs/${AWS::AccountId}/*'
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref 'AWS::AccountId'
                s3:x-amz-acl: bucket-owner-full-control
  CodePipelineArtifactsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${CodePipelineArtifactsBucketName}-${AWS::AccountId}-${AWS::Region}'
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
        - Key: Name
          Value: !Sub '${CodePipelineArtifactsBucketName}-artifacts'
  ECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      EmptyOnDelete: true
      ImageScanningConfiguration:
        ScanOnPush: false
      RepositoryName: !Ref 'ECRRepositoryName'
      EncryptionConfiguration:
        EncryptionType: AES256
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
  HostedZone:
    Type: AWS::Route53::HostedZone
    Properties:
      Name: !Ref 'DomainName'
      HostedZoneConfig:
        Comment: !Sub 'Hosted zone for ${DomainName}'
      HostedZoneTags:
        - Key: Name
          Value: !Sub '${DomainName}-hosted-zone'
        - Key: Application
          Value: !Ref 'AppName'
  NameserverUpdateRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: Route53Access
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - route53domains:UpdateDomainNameservers
                  - route53domains:GetDomainDetail
                  - route53:GetHostedZone
                Resource: '*'
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  NameserverUpdateFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-nameserver-updater'
      Runtime: python3.9
      Handler: index.handler
      Role: !GetAtt 'NameserverUpdateRole.Arn'
      Timeout: 60
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse

          def handler(event, context):
              print(f"Event: {json.dumps(event)}")
              
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      route53_domains = boto3.client('route53domains', region_name='us-east-1')
                      route53 = boto3.client('route53')
                      
                      domain_name = event['ResourceProperties']['DomainName']
                      hosted_zone_id = event['ResourceProperties']['HostedZoneId']
                      
                      # Get nameservers from hosted zone
                      print(f"Getting nameservers for hosted zone: {hosted_zone_id}")
                      response = route53.get_hosted_zone(Id=hosted_zone_id)
                      nameservers = response['DelegationSet']['NameServers']
                      print(f"Hosted zone nameservers: {nameservers}")
                      
                      # Get current domain nameservers
                      domain_info = route53_domains.get_domain_detail(DomainName=domain_name)
                      current_nameservers = [ns['Name'] for ns in domain_info['Nameservers']]
                      print(f"Current domain nameservers: {current_nameservers}")
                      
                      # Check if update is needed
                      if set(nameservers) != set(current_nameservers):
                          print("Updating domain nameservers...")
                          route53_domains.update_domain_nameservers(
                              DomainName=domain_name,
                              Nameservers=[{'Name': ns} for ns in nameservers]
                          )
                          print("Nameservers updated successfully")
                      else:
                          print("Nameservers already match, no update needed")
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'HostedZoneNameServers': nameservers,
                          'DomainNameServers': nameservers,
                          'Message': 'Nameservers synchronized successfully'
                      })
                  else:
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })
  NameserverSync:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt 'NameserverUpdateFunction.Arn'
      DomainName: !Ref 'DomainName'
      HostedZoneId: !Ref 'HostedZone'
  SSLCertificate:
    Type: AWS::CertificateManager::Certificate
    DependsOn: NameserverSync
    Properties:
      DomainName: !Ref 'DomainName'
      SubjectAlternativeNames:
        - !Ref 'SubdomainName'
      ValidationMethod: DNS
      DomainValidationOptions: !If
        - IsWildcardSubDomain
        - - DomainName: !Ref 'DomainName'
            HostedZoneId: !Ref 'HostedZone'
        - - DomainName: !Ref 'DomainName'
            HostedZoneId: !Ref 'HostedZone'
          - DomainName: !Ref 'SubdomainName'
            HostedZoneId: !Ref 'HostedZone'
      Tags:
        - Key: Name
          Value: !Sub '${DomainName}-certificate'
        - Key: Application
          Value: !Ref 'AppName'
  ApexDomainRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref 'HostedZone'
      Name: !Sub '${DomainName}.'
      Type: A
      AliasTarget:
        DNSName: !If
          - CreateNewBucket
          - !GetAtt 'LoadBalancerWithNewBucket.DNSName'
          - !GetAtt 'LoadBalancerWithExistingBucket.DNSName'
        HostedZoneId: !If
          - CreateNewBucket
          - !GetAtt 'LoadBalancerWithNewBucket.CanonicalHostedZoneID'
          - !GetAtt 'LoadBalancerWithExistingBucket.CanonicalHostedZoneID'
        EvaluateTargetHealth: false
  SubDomainRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref 'HostedZone'
      Name: !Sub '${SubdomainName}.'
      Type: A
      AliasTarget:
        DNSName: !If
          - CreateNewBucket
          - !GetAtt 'LoadBalancerWithNewBucket.DNSName'
          - !GetAtt 'LoadBalancerWithExistingBucket.DNSName'
        HostedZoneId: !If
          - CreateNewBucket
          - !GetAtt 'LoadBalancerWithNewBucket.CanonicalHostedZoneID'
          - !GetAtt 'LoadBalancerWithExistingBucket.CanonicalHostedZoneID'
        EvaluateTargetHealth: false
  LoadBalancerWithNewBucket:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Condition: CreateNewBucket
    DependsOn: AccessLogsBucketPolicy
    Properties:
      SecurityGroups:
        - !Ref 'LoadBalancerSecurityGroup'
      LoadBalancerAttributes:
        - Key: access_logs.s3.enabled
          Value: 'true'
        - Key: access_logs.s3.bucket
          Value: !Ref 'AccessLogsBucket'
        - Key: access_logs.s3.prefix
          Value: ''
      Subnets:
        - !Ref 'PublicSubnetAz1'
        - !Ref 'PublicSubnetAz2'
      Type: application
      Scheme: internet-facing
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Name: !Sub '${AppName}-alb'
  LoadBalancerWithExistingBucket:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Condition: UseExistingAccessLogsBucket
    Properties:
      SecurityGroups:
        - !Ref 'LoadBalancerSecurityGroup'
      LoadBalancerAttributes:
        - Key: access_logs.s3.enabled
          Value: 'true'
        - Key: access_logs.s3.bucket
          Value: !Sub '${AWS::StackName}-alb-access-logs-${AWS::AccountId}'
        - Key: access_logs.s3.prefix
          Value: ''
      Subnets:
        - !Ref 'PublicSubnetAz1'
        - !Ref 'PublicSubnetAz2'
      Type: application
      Scheme: internet-facing
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Name: !Sub '${AppName}-alb'
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${AppName}-tg'
      VpcId: !Ref 'VPC'
      Protocol: HTTP
      Port: 80
      HealthCheckPath: /up
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 5
      UnhealthyThresholdCount: 2
      Matcher:
        HttpCode: '200'
      TargetType: ip
      TargetGroupAttributes:
        - Key: load_balancing.cross_zone.enabled
          Value: use_load_balancer_configuration
        - Key: deregistration_delay.timeout_seconds
          Value: '300'
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  HTTPSListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !If
        - CreateNewBucket
        - !Ref 'LoadBalancerWithNewBucket'
        - !Ref 'LoadBalancerWithExistingBucket'
      Port: 443
      Protocol: HTTPS
      SslPolicy: ELBSecurityPolicy-TLS13-1-2-Res-2021-06
      Certificates:
        - CertificateArn: !Ref 'SSLCertificate'
      DefaultActions:
        - Order: 1
          TargetGroupArn: !Ref 'TargetGroup'
          Type: forward
          ForwardConfig:
            TargetGroupStickinessConfig:
              Enabled: false
              DurationSeconds: 3600
            TargetGroups:
              - TargetGroupArn: !Ref 'TargetGroup'
                Weight: 1
      ListenerAttributes:
        - Key: routing.http.response.server.enabled
          Value: 'true'
  HTTPListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !If
        - CreateNewBucket
        - !Ref 'LoadBalancerWithNewBucket'
        - !Ref 'LoadBalancerWithExistingBucket'
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Order: 1
          Type: redirect
          RedirectConfig:
            Path: /#{path}
            Host: '#{host}'
            Query: '#{query}'
            Protocol: HTTPS
            StatusCode: HTTP_301
            Port: '443'
      ListenerAttributes:
        - Key: routing.http.response.server.enabled
          Value: 'true'
  RailsMasterKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Name: !Sub 'prod/${AppName}/rails_master_key'
      Description: Rails master key for encryption
      SecretString: !Sub '{"RAILS_MASTER_KEY": "${RailsMasterKey}"}'
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Ref 'AppName'
      CapacityProviders:
        - FARGATE
        - FARGATE_SPOT
      ClusterSettings:
        - Name: containerInsights
          Value: disabled
      Configuration:
        ExecuteCommandConfiguration:
          Logging: DEFAULT
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AppName}-ecsTaskRoleForEcsExec'
      Policies:
        - PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Resource: '*'
                Action:
                  - ssmmessages:CreateControlChannel
                  - ssmmessages:CreateDataChannel
                  - ssmmessages:OpenControlChannel
                  - ssmmessages:OpenDataChannel
                Effect: Allow
          PolicyName: ecsExecPolicy
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Condition:
              StringEquals:
                aws:SourceAccount: !Ref 'AWS::AccountId'
              ArnLike:
                aws:SourceArn: !Sub 'arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:*'
            Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  ECSTaskExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
      RoleName: !Sub '${AppName}-ecsTaskExecutionRole'
      Description: Allows ECS tasks to call AWS services on your behalf.
      Policies:
        - PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
                Action:
                  - logs:CreateLogGroup
                Effect: Allow
          PolicyName: CreateLogGroupPolicy
        - PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Resource:
                  - !GetAtt 'DatabaseCluster.MasterUserSecret.SecretArn'
                  - !Ref 'RailsMasterKeySecret'
                Action:
                  - secretsmanager:GetSecretValue
                Effect: Allow
          PolicyName: secretManagerGetSecretValuepolicy
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  ECSTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      TaskRoleArn: !GetAtt 'ECSTaskRole.Arn'
      ExecutionRoleArn: !GetAtt 'ECSTaskExecutionRole.Arn'
      Memory: '512'
      ContainerDefinitions:
        - Secrets:
            - Name: RAILS_MASTER_KEY
              ValueFrom: !Sub '${RailsMasterKeySecret}:RAILS_MASTER_KEY::'
            - Name: CODE_PIPELINE_TUTORIAL_DATABASE_USERNAME
              ValueFrom: !Sub '${DatabaseCluster.MasterUserSecret.SecretArn}:username::'
            - Name: CODE_PIPELINE_TUTORIAL_DATABASE_PASSWORD
              ValueFrom: !Sub '${DatabaseCluster.MasterUserSecret.SecretArn}:password::'
          Image: !If
            - UseECRImage
            - !GetAtt 'ECRRepository.RepositoryUri'
            - nginx:latest
          Essential: true
          LogConfiguration:
            Options:
              awslogs-group: !Sub '/ecs/${AppName}'
              awslogs-create-group: 'true'
              awslogs-region: !Ref 'AWS::Region'
              awslogs-stream-prefix: ecs
            LogDriver: awslogs
          Name: !Ref 'AppName'
          LinuxParameters:
            InitProcessEnabled: true
          PortMappings:
            - ContainerPort: !If [UseECRImage, 3000, 80]
              Protocol: tcp
              HostPort: !If [UseECRImage, 3000, 80]
              Name: !Sub 'port-3000-tcp'
          Environment:
            - Name: CODE_PIPELINE_TUTORIAL_DATABASE_DBNAME
              Value: !Sub '${AppName}_db'
            - Name: DB_HOST
              Value: !GetAtt 'DatabaseCluster.Endpoint.Address'
      Cpu: '256'
      RequiresCompatibilities:
        - FARGATE
      Family: !Sub '${AppName}_family'
      NetworkMode: awsvpc
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  ECSService:
    Type: AWS::ECS::Service
    DependsOn: HTTPSListener
    Properties:
      Cluster: !Ref 'ECSCluster'
      CapacityProviderStrategy:
        - CapacityProvider: FARGATE
          Base: 0
          Weight: 1
      TaskDefinition: !Ref 'ECSTaskDefinition'
      ServiceName: !Ref 'AppName'
      DesiredCount: !If [UseECRImage, 1, 0]
      AvailabilityZoneRebalancing: ENABLED
      LoadBalancers:
        - ContainerName: !Ref 'AppName'
          ContainerPort: !If [UseECRImage, 3000, 80]
          TargetGroupArn: !Ref 'TargetGroup'
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - !Ref 'ECSTaskSecurityGroup'
          Subnets:
            - !Ref 'PrivateSubnetAz1'
            - !Ref 'PrivateSubnetAz2'
      DeploymentConfiguration:
        DeploymentCircuitBreaker:
          Enable: true
          Rollback: true
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      EnableExecuteCommand: true
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-codebuild-role'
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Policies:
        - PolicyName: CodeBuildServiceRolePolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*'
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectVersion
                  - s3:PutObject
                Resource: !Sub '${CodePipelineArtifactsBucket.Arn}/*'
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:GetAuthorizationToken
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                  - ecr:PutImage
                Resource: '*'
  CodeBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub '${AWS::StackName}-build-project'
      Description: Build Docker image and push to ECR
      ServiceRole: !GetAtt 'CodeBuildServiceRole.Arn'
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_MEDIUM
        Image: aws/codebuild/standard:7.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: AWS_DEFAULT_REGION
            Value: !Ref 'AWS::Region'
          - Name: AWS_ACCOUNT_ID
            Value: !Ref 'AWS::AccountId'
          - Name: IMAGE_REPO_NAME
            Value: !Ref 'ECRRepository'
          - Name: IMAGE_TAG
            Value: latest
          - Name: CONTAINER_NAME
            Value: !GetAtt 'ECSService.Name'
      Source:
        Type: CODEPIPELINE
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo Logging in to Amazon ECR...
                - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com
                - REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME
                - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7)
                - IMAGE_TAG=${COMMIT_HASH:=latest}
            build:
              commands:
                - echo Build started on `date`
                - echo Building the Docker image...
                - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .
                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $REPOSITORY_URI:$IMAGE_TAG
                - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $REPOSITORY_URI:latest
            post_build:
              commands:
                - echo Build completed on `date`
                - echo Pushing the Docker images...
                - docker push $REPOSITORY_URI:$IMAGE_TAG
                - docker push $REPOSITORY_URI:latest
                - echo Writing image definitions file...
                - printf '[{"name":"%s","imageUri":"%s"}]' $CONTAINER_NAME $REPOSITORY_URI:$IMAGE_TAG > imagedefinitions.json
                - cat imagedefinitions.json
          artifacts:
            files:
              - imagedefinitions.json
  CodePipelineServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-codepipeline-role'
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: codepipeline.amazonaws.com
            Action: sts:AssumeRole
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      Policies:
        - PolicyName: CodePipelineServiceRolePolicy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetBucketVersioning
                  - s3:GetObject
                  - s3:GetObjectVersion
                  - s3:PutObject
                Resource:
                  - !Sub '${CodePipelineArtifactsBucket.Arn}/*'
                  - !GetAtt 'CodePipelineArtifactsBucket.Arn'
              - Effect: Allow
                Action:
                  - codestar-connections:UseConnection
                Resource: !Ref 'CodeStarConnectionArn'
              - Effect: Allow
                Action:
                  - codebuild:BatchGetBuilds
                  - codebuild:StartBuild
                Resource: !GetAtt 'CodeBuildProject.Arn'
              - Effect: Allow
                Action:
                  - ecs:DescribeServices
                  - ecs:DescribeTaskDefinition
                  - ecs:DescribeTasks
                  - ecs:ListTasks
                  - ecs:RegisterTaskDefinition
                  - ecs:UpdateService
                  - ecs:DescribeClusters
                  - ecs:ListServices
                  - ecs:CreateTaskSet
                  - ecs:UpdateTaskSet
                  - ecs:DeleteTaskSet
                  - ecs:TagResource
                  - ecs:UntagResource
                  - ecs:ListTagsForResource
                Resource: '*'
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - !GetAtt 'ECSTaskExecutionRole.Arn'
                  - !GetAtt 'ECSTaskRole.Arn'
                Condition:
                  StringEqualsIfExists:
                    iam:PassedToService:
                      - ecs-tasks.amazonaws.com
  CodePipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      Name: !Sub '${AppName}-pipeline'
      RoleArn: !GetAtt 'CodePipelineServiceRole.Arn'
      Tags:
        - Key: Application
          Value: !Ref 'AppName'
      ArtifactStore:
        Type: S3
        Location: !Ref 'CodePipelineArtifactsBucket'
      Stages:
        - Name: Source
          Actions:
            - Name: SourceAction
              ActionTypeId:
                Category: Source
                Owner: AWS
                Provider: CodeStarSourceConnection
                Version: '1'
              Configuration:
                ConnectionArn: !Ref 'CodeStarConnectionArn'
                FullRepositoryId: !Ref 'GitHubRepo'
                BranchName: !Ref 'GitHubBranch'
                OutputArtifactFormat: CODE_ZIP
              OutputArtifacts:
                - Name: SourceOutput
        - Name: Build
          Actions:
            - Name: Build
              ActionTypeId:
                Category: Build
                Owner: AWS
                Provider: CodeBuild
                Version: '1'
              Configuration:
                ProjectName: !Ref 'CodeBuildProject'
              InputArtifacts:
                - Name: SourceOutput
              OutputArtifacts:
                - Name: BuildOutput
        - Name: Deploy
          Actions:
            - Name: Deploy
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Provider: ECS
                Version: '1'
              Configuration:
                ClusterName: !Ref 'ECSCluster'
                ServiceName: !GetAtt 'ECSService.Name'
                FileName: imagedefinitions.json
              InputArtifacts:
                - Name: BuildOutput
Outputs:
  RootDomainURL:
    Description: Primary HTTPS URL served by the application domain
    Value: !Sub 'https://${DomainName}'
  SubdomainURL:
    Description: Alternate HTTPS URL served from the configured subdomain
    Value: !Sub 'https://${SubdomainName}'
  LoadBalancerDNSName:
    Description: Direct DNS name of the public Application Load Balancer
    Value: !If
      - CreateNewBucket
      - !GetAtt 'LoadBalancerWithNewBucket.DNSName'
      - !GetAtt 'LoadBalancerWithExistingBucket.DNSName'
  Route53HostedZoneId:
    Description: ID of the Route 53 hosted zone created for the application domain
    Value: !Ref 'HostedZone'
  Route53NameServers:
    Description: Name server records to configure at your domain registrar
    Value: !Join [', ', !GetAtt 'HostedZone.NameServers']
  NameserverSyncMessage:
    Description: Result message from the Route 53 nameserver synchronization Lambda
    Value: !GetAtt 'NameserverSync.Message'
  ALBAccessLogsBucket:
    Description: S3 bucket storing ALB access logs (existing or newly created)
    Value: !If
      - CreateNewBucket
      - !Ref 'AccessLogsBucket'
      - !Sub '${AWS::StackName}-alb-access-logs-${AWS::AccountId}'
  CodePipelineArtifactsBucket:
    Description: S3 bucket used by CodePipeline to store build artifacts
    Value: !Ref 'CodePipelineArtifactsBucket'
  CodePipelineName:
    Description: Name of the AWS CodePipeline responsible for CI/CD deployments
    Value: !Ref 'CodePipeline'
  ECRRepositoryURI:
    Description: URI of the Amazon ECR repository for application container images
    Value: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${ECRRepository}'
  ECSClusterName:
    Description: Name of the Amazon ECS cluster running the application service
    Value: !Ref 'ECSCluster'
  ECSServiceName:
    Description: Name of the ECS service deployed by the pipeline
    Value: !Ref 'ECSService'
  DatabaseSecretArn:
    Description: ARN of the Secrets Manager entry containing database credentials
    Value: !GetAtt 'DatabaseCluster.MasterUserSecret.SecretArn'
  DatabaseClusterEndpoint:
    Description: Reader/Writer endpoint for the Aurora database cluster
    Value: !GetAtt 'DatabaseCluster.Endpoint.Address'
  DatabaseSnapshotUsed:
    Description: Snapshot identifier used to provision the database (if any)
    Value: !If
      - UseAutomaticLookup
      - !GetAtt 'LatestSnapshotLookup.LatestSnapshotId'
      - !If
        - CreateNewCluster
        - None
        - !Ref 'DatabaseSnapshotIdentifier'
  DatabaseSnapshotCreateTime:
    Condition: UseAutomaticLookup
    Description: ISO timestamp of the automatically selected snapshot
    Value: !GetAtt 'LatestSnapshotLookup.SnapshotCreateTime'
